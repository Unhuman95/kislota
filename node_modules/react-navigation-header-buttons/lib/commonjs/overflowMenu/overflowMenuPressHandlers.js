"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overflowMenuPressHandlerPopupMenu = exports.overflowMenuPressHandlerDropdownMenu = exports.overflowMenuPressHandlerActionSheet = exports.extractOverflowButtonData = exports.extractHiddenItemProps = exports.defaultOnOverflowMenuPress = void 0;
var _reactNative = require("react-native");
var _HeaderItems = require("../HeaderItems.js");
var _reactToImperative = _interopRequireDefault(require("react-to-imperative"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const extractOverflowButtonData = hiddenButtons => {
  return (0, _reactToImperative.default)(hiddenButtons, extractHiddenItemProps);
};
exports.extractOverflowButtonData = extractOverflowButtonData;
const extractHiddenItemProps = ({
  props,
  type
}) => {
  if (type === _HeaderItems.HiddenItem) {
    return props;
  }
  return true;
};
exports.extractHiddenItemProps = extractHiddenItemProps;
const overflowMenuPressHandlerActionSheet = ({
  hiddenButtons,
  cancelButtonLabel = 'Cancel'
}) => {
  let actionTitles = hiddenButtons.map(btn => btn.title);
  actionTitles.unshift(cancelButtonLabel);
  const disabledButtonIndices = (() => {
    let result = [];
    hiddenButtons.forEach((it, index) => {
      if (it.disabled) {
        result.push(index + 1);
      }
    });
    return result;
  })();
  const destructiveButtonIndex = (() => {
    let result = [];
    hiddenButtons.forEach((it, index) => {
      if (it.destructive) {
        result.push(index + 1);
      }
    });
    return result;
  })();
  _reactNative.ActionSheetIOS.showActionSheetWithOptions({
    options: actionTitles,
    cancelButtonIndex: 0,
    disabledButtonIndices,
    destructiveButtonIndex
  }, buttonIndex => {
    if (buttonIndex > 0) {
      hiddenButtons[buttonIndex - 1]?.onPress?.();
    }
  });
};
exports.overflowMenuPressHandlerActionSheet = overflowMenuPressHandlerActionSheet;
const overflowMenuPressHandlerPopupMenu = ({
  hiddenButtons,
  overflowButtonRef
}) => {
  const enabledButtons = hiddenButtons.filter(it => it.disabled !== true);
  // @ts-expect-error TODO vonovak this was removed in RN 0.75
  const presenter = _reactNative.UIManager.showPopupMenu;
  const node = (0, _reactNative.findNodeHandle)(overflowButtonRef);
  if (!presenter || !node) {
    console.warn('could not present overflow menu using showPopupMenu(). This is only available on Android with RN <= 0.75. See https://github.com/vonovak/react-navigation-header-buttons/issues/252');
    return;
  }
  presenter(node, enabledButtons.map(btn => btn.title), () => console.debug('overflowBtn error'), (eventName, index) => {
    if (eventName !== 'itemSelected' || typeof index !== 'number') {
      return;
    }
    enabledButtons[index]?.onPress?.();
  });
};
exports.overflowMenuPressHandlerPopupMenu = overflowMenuPressHandlerPopupMenu;
const overflowMenuPressHandlerDropdownMenu = ({
  children,
  overflowButtonRef,
  presentMenu
}) => {
  if (overflowButtonRef) {
    overflowButtonRef.measureInWindow((x, y, width) => {
      presentMenu({
        elements: children,
        x: x + width,
        y
      });
    });
  } else {
    console.error('overflowButtonRef is null, cannot show overflow menu');
  }
};
exports.overflowMenuPressHandlerDropdownMenu = overflowMenuPressHandlerDropdownMenu;
const defaultOnOverflowMenuPress = exports.defaultOnOverflowMenuPress = _reactNative.Platform.select({
  ios: overflowMenuPressHandlerActionSheet,
  default: overflowMenuPressHandlerDropdownMenu
});
//# sourceMappingURL=overflowMenuPressHandlers.js.map